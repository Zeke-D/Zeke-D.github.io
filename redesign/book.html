<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Ezekiel D'Ascoli</title>
    <style>
      body { 
        margin: 0;
        height: 300vh;
      }

      canvas {
        position: fixed;
        top: 0;
        left: 0;
      }
    </style>
  </head>
  <body>
    <script src='js/three.js'></script>
    <script>
      const TAU = 6.283;
      // l(inearly)-(int)erp(olates) between a and b based on ratio [0, 1] t
      function lerp(a, b, t) { return a + t * (b - a); }
      function easeout(a, b, t) { return lerp(a, b, Math.sqrt(t)); }
      function easein(a, b, t) { return lerp(a, b, t*t); }
      function easeinout(a, b, t) { return lerp(easein(a, b, t), easeout(a, b, t), t); }

      /* 
      We want to make a book. Things we need to be able to do:
      - Create n pages between 2 covers
      - Flip to any page (next, previous, n):
        - This involves every page < n also being flipped up first
        - Every page > n flipped down
        - Intuition says a while loop since we will always be going in linear order
        - If desired index > current index, flip each page up until we reach page
        - If desired index < current index, flip each page down until we reach page
        - If des = cur, do nothin'
      */

      // TODO: take in projects array, texture cubes based on projs
      // for now, constructs n pages and returns them as an array of THREE objs
      function makeBook(numPages) {
        let origin = new THREE.Vector3(0, -1, 0);
        const geo = new THREE.BoxGeometry(3, 2, .025);
        const mat = new THREE.MeshBasicMaterial({ color: 0x0088CC });
        const frontCover = new THREE.Mesh(geo, mat);
        frontCover.position.x = origin.x;
        frontCover.position.y = origin.y;
        frontCover.position.z = origin.z;
        // mat.color = 0xaa0480;
        const backCover  = new THREE.Mesh(geo, mat);
        let pageThickness = .0125;
        let pages = [frontCover];
        for (let i = 0; i < numPages; i++) {
          const pageGeo = new THREE.BoxGeometry(3, 2, pageThickness);
          const pageMat = new THREE.MeshBasicMaterial({ color: 0xfcf7e8 });
          const page = new THREE.Mesh(pageGeo, pageMat);
          page.position.x = origin.x
          page.position.y = origin.y
          page.position.z = origin.z - .25 + i * pageThickness;
          pages.push(page);
        }
        backCover.position.x = origin.x
        backCover.position.y = origin.y
        backCover.position.z = origin.z - 0.25 + numPages * pageThickness + 0.25;
        pages.push(backCover);
        return pages;
      }

      // sets up camera and renderer
      function setupCamera() {
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, .1, 1000);
        camera.position.z = 5;
        renderer.setSize(window.innerWidth, window.innerHeight);
        return camera
      }


      const scene = new THREE.Scene();
      const renderer = new THREE.WebGLRenderer();
      document.body.appendChild(renderer.domElement);
      let camera = setupCamera();

      // reset aspect ratio when browser is resized
      window.onresize = _ => camera = setupCamera();

      let totalTurns = -.5;
      
      let pages = makeBook(5);
      for (let i in pages) { 
        registerFlipAnimation(pages[i], Math.sqrt(i)*200);
        console.log(pages[i].animInfo)
        scene.add(pages[i]);
      }
      let cube = pages[0]

      function registerFlipAnimation(object, delay) {
        if (object.animInfo != undefined) {
          console.info("Already animating");
          return;
        }
        // register info on object to be picked up in anim loop
        object.animInfo = {
          timeMs:  0,
          delayMs: delay,
          durationMs: 1000,
          xRot:  [ object.rotation.x, object.rotation.x + -.5 * TAU ],
          yPos:  [ object.position.y, object.position.y + 2],
        };
        console.log("Registered object animation.")
      }

      let lastTime = +(new Date());
      function animate() {
        // update deltaTime to reflect frame time diffs
        let currentTime = +(new Date());
        let deltaTime = currentTime - lastTime;
        lastTime = currentTime;

        // this only works for full screen apps, ignores canvas offset
        let scrollProgress = window.scrollY / (document.body.scrollHeight - window.innerHeight);

        // animate all the objects that think they need animating
        for (let object of pages) {
          if (!object.animInfo) {
            continue;
          }
          
          // step animation
          object.animInfo.timeMs += deltaTime;
          object.animInfo.timeMs = Math.min(object.animInfo.timeMs, 
                                            object.animInfo.durationMs + object.animInfo.delayMs);

          // rotate based on current time
          if (object.animInfo.timeMs >= object.animInfo.delayMs) {
            let progress = (object.animInfo.timeMs-object.animInfo.delayMs)/object.animInfo.durationMs;
            object.rotation.x = easein( object.animInfo.xRot[0],  object.animInfo.xRot[1], progress)
            object.position.y = easein( object.animInfo.yPos[0],  object.animInfo.yPos[1], progress);
          }
          
          if (object.animInfo.timeMs >= object.animInfo.durationMs + object.animInfo.delayMs) {
            console.log("Anim ended")
            object.animInfo = undefined;
          }
        }
        
        renderer.render(scene, camera);
        
        requestAnimationFrame(animate);
      }

      animate()
      
    </script>
  </body>
</html>