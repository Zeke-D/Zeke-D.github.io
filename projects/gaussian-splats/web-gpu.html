<!doctype html>
<html>
  <head>
    <style>
      html {
        width: 100vw;
      }
      body {
        width: 100%;
        margin: 0;
        padding: 0;
        display: grid;
        grid-columns: 1fr [content-start] min-width [content-end] 1fr;
      }
      canvas {
        margin-top: 100px;
        grid-column: content;
      }
    </style>
  </head>
  <body>
    <canvas width="600" height="600"></canvas>
    <script type="module">

      const GRID_SIZE = 8;
    
      const canvas = document.querySelector("canvas");
      
      if (!navigator.gpu) throw new Error("WebGPU is not supported in this browser.");
      
      const adapter = await navigator.gpu.requestAdapter();
      if (!adapter) throw new Error("No appropriate GPUAdapter found.")
      
      const device = await adapter.requestDevice();
      const context = canvas.getContext("webgpu");
      const canvasFormat = navigator.gpu.getPreferredCanvasFormat();
      context.configure({
        device: device,
        format: canvasFormat,
      });

      // vertices for clip-space quad
      const clipQuadVerts = new Float32Array([
        -.8, -.8,
         .8, -.8,
         .8,  .8,
        -.8, -.8,
         .8,  .8,
        -.8,  .8
      ])

      const vertexBuffer = device.createBuffer({
        label: "Quad Vertices", // optional, but makes debugging much easier
        size: clipQuadVerts.byteLength, // 4 bytes per float * 2 floats per vert * 6 verts
        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
      })

      // (buffer, offset, data)
      device.queue.writeBuffer(vertexBuffer, 0, clipQuadVerts);
      const vertexBufferLayout = {
        arrayStride: 4 * 2,
        attributes: [{
          format: "float32x2",
          offset: 0,
          shaderLocation: 0, // for reference in vertex shader
        }]
      }

      // uniform array to hold width and height of grid
      const uniformArray = new Float32Array([GRID_SIZE, GRID_SIZE]);
      const uniformBuffer = device.createBuffer({
        label: "Grid Uniforms",
        size: uniformArray.byteLength,
        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,
      })
      device.queue.writeBuffer(uniformBuffer, 0, uniformArray);
      
      const conwayShaderModule = device.createShaderModule({
        label: "Conway shader",
        code: `
          @group(0) @binding(0) var<uniform> gridSize: vec2f;
          @vertex
          fn vertexMain(@location(0) pos: vec2f) -> @builtin(position) vec4f {
            let gridPos: vec2f = (pos - gridSize + 1) / gridSize;
            return vec4f(gridPos, 0, 1);
          }

          @fragment
          fn fragmentMain() -> @location(0) vec4f {
            return vec4f(.8, 0, .3, 1);
          }
        `
      });

      const conwayPipeline = device.createRenderPipeline({
        label: "Conway Pipeline",
        layout: "auto",
        vertex: {
          module: conwayShaderModule,
          entryPoint: "vertexMain",
          buffers: [vertexBufferLayout]
        },
        fragment: {
          module: conwayShaderModule,
          entryPoint: "fragmentMain",
          targets: [{
            format: canvasFormat
          }]
        }
      });
      
      const bindGroup = device.createBindGroup({
        label: "Bind group for Conway sim",
        layout: conwayPipeline.getBindGroupLayout(0),
        entries: [{
          binding: 0,
          resource: { buffer: uniformBuffer }
        }],
      });


      const encoder = device.createCommandEncoder();
      const pass = encoder.beginRenderPass({
        colorAttachments: [{
          view: context.getCurrentTexture().createView(),
          loadOp: "clear",
          clearValue: [.1, 0, .3, 1],
          storeOp: "store",
        }]
      });

      pass.setPipeline(conwayPipeline);
      pass.setVertexBuffer(0, vertexBuffer);
      pass.setBindGroup(0, bindGroup);
      pass.draw(clipQuadVerts.length / 2);
      pass.end();
      
      device.queue.submit([encoder.finish()]);
      
    </script>
  </body>
</html>
